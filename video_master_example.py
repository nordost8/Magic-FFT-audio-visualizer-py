"""
This script demonstrates how to create a final video using Vidgear from snapshots generated
by FFT analyzer. It utilizes the 'video_master' module to assemble the snapshots into
a complete video with desired settings such as framerate, resolution, etc. The snapshots,
previously generated by the FFT visualizer, are used as frames to create the final video.

To generate video with animation, run `video_master_example.py`.
After that, you can add your MP3 audio files to the `resource/music_files` directory,
which will gradually be incorporated into the video.
You will see the progress percentage in the console.
The finalized videos will be saved in the `resource/ready_videos` directory.

"""

import os
import random
import time

import numpy as np
import pygame
from pydub import AudioSegment

import fft_analyzer
from vidgear.gears import WriteGear
import cv2

ROOT_DIRECTORY = os.getcwd()
PATH_TO_VIDEOS_FOLDER = os.path.join(ROOT_DIRECTORY, 'resource/ready_videos')


class DynamicWriter:
    TARGET_FRAME_RATE = 24

    def __init__(self, audio_path, audio_name):

        output_params = {
            "-vcodec": "libx264",
            "-pix_fmt": "yuv420p",
            "-preset": "ultrafast",
            "-b:v": "5M",
            "-profile:v": "high",
            "-level:v": "4.1",
            "-crf": "18",
            "-input_framerate": self.TARGET_FRAME_RATE,  # MANDATORY FIELD FOR WriteGear (!) HERE, FPS IS ALSO REQUIRED.
            "-r": self.TARGET_FRAME_RATE
        }
        self.writer = WriteGear(output=ROOT_DIRECTORY + '/temp/result.mp4', **output_params)
        self.audio_path = audio_path
        self.audio_name = audio_name

    def __del__(self):
        self.stop()

    def stop(self):
        self.writer.close()
        time.sleep(1)

        ffmpeg_command = [
            "-y",
            "-i",
            ROOT_DIRECTORY + "/temp/result.mp4",
            "-c:v",
            "libx264",
            "-preset",
            "ultrafast",
            "-r",
            "60",
            ROOT_DIRECTORY + "/temp/result_60_fps.mp4",
        ]

        self.writer.execute_ffmpeg_cmd(ffmpeg_command)

        time.sleep(1)

        ffmpeg_command = [
            "-y",
            "-i",
            ROOT_DIRECTORY + "/temp/result_60_fps.mp4",
            "-i",
            self.audio_path,
            "-c:v",
            "copy",
            "-c:a",
            "copy",
            "-map",
            "0:v:0",
            "-map",
            "1:a:0",
            "-shortest",
            PATH_TO_VIDEOS_FOLDER + "/" + self.audio_name + '.mp4',
        ]

        self.writer.execute_ffmpeg_cmd(ffmpeg_command)

        temp_folder_path = ROOT_DIRECTORY + "/temp/"
        file_list = os.listdir(temp_folder_path)
        for file_name in file_list:
            file_path = os.path.join(temp_folder_path, file_name)
            os.remove(file_path)

    def ready_frame_callback(self, pygame_surface):
        frame_data = pygame.surfarray.array3d(pygame_surface)
        frame_data = np.swapaxes(frame_data, 0, 1)
        frame_bgr = cv2.cvtColor(frame_data, cv2.COLOR_RGB2BGR)
        self.writer.write(frame_bgr)


def get_file_paths_and_names(path, format=''):
    result = {}
    for file_name in os.listdir(path):
        if file_name.endswith(format):
            file_path = os.path.join(path, file_name)
            track_name = os.path.splitext(file_name)[0]
            result[track_name] = file_path
    return result


def enchant_audio(audio_path, audio_name):
    audio = AudioSegment.from_mp3(audio_path)
    audio_duration_in_ms = int(audio.duration_seconds) * 1000
    audio = audio[:audio_duration_in_ms]
    audio = audio.fade_in(7000).fade_out(7000)
    audio = audio + AudioSegment.silent(duration=3000)

    output_audio = AudioSegment(audio.raw_data, frame_rate=audio.frame_rate,
                                sample_width=audio.sample_width,
                                channels=audio.channels)

    audio_path_enchaned = ROOT_DIRECTORY + '/temp/' + audio_name + '.mp3'
    output_audio.export(audio_path_enchaned, format="mp3")
    return audio_path_enchaned


def run():
    while True:
        time.sleep(1)
        audios = get_file_paths_and_names(os.path.join(ROOT_DIRECTORY, 'resource/music_files'), '.mp3')
        videos = get_file_paths_and_names(PATH_TO_VIDEOS_FOLDER, '.mp4')
        render_needed = [audio_name for audio_name, audio_path in audios.items() if audio_name not in videos]
        random.shuffle(render_needed)
        for audio_name in render_needed:
            audio_path = audios[audio_name]
            audio_path_enchanted = enchant_audio(audio_path, audio_name)
            dw = DynamicWriter(audio_path=audio_path_enchanted, audio_name=audio_name)
            fft_analyzer.fft_analyzer(audio_path=audio_path_enchanted, ready_frame_callback=dw.ready_frame_callback)
            dw.stop()


if __name__ == '__main__':
    run()
